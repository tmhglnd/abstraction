<!DOCTYPE html>
<head>
	<title>ABSTRACTION | by Timo Hoogland | 2023</title>

	<!-- include the amazing hydra-synth by Olivia Jack -->
	<script src="./node_modules/hydra-synth/dist/hydra-synth.js"></script>
	<!-- socket.io for communication between browser and device -->
	<script src="./node_modules/socket.io/client-dist/socket.io.min.js"></script>
	<!-- include the p5.js library for sound processing -->
	<script src="./node_modules/p5/lib/p5.js"></script>
	<script src="./node_modules/p5/lib/addons/p5.sound.js"></script>

	<style>
		@import url('./fonts/UbuntuMono-Regular.ttf');

		/* The style of the page body */
		html, body {
			font-family: 'Ubuntu Mono', monospace;
			font-size: 1.7vw;
			line-height: 1.3;
			width: 100%;
			height: 100%;
			margin: 0px;
			overflow: hidden;
		}

		/* style for the code sections */
		div {
			display:table; 
			column-count:2; 
			width: 100%;
			height: 50%;
		}

		p {
			padding: 5%;
			width: 50%;
			height: 100%;
			border: 0;
			display: table-cell;
		}
		
		/* highlight the code and blend with background */
		mark {
			background-color: magenta;
			color: cyan;
			mix-blend-mode: difference;
		}

		.canvas {
			z-index: -1000;
			position: fixed;
		}
	</style>
</head>
<body>
	<!-- the visual canvas -->
	<canvas id="hydra-canvas" class="canvas"></canvas>
	<!-- the 3 code sections overlaying the canvas -->
	<div>
		<p id="o0"></p>
		<p id="o1"></p>
	</div>
	<div>
		<p id="o2"></p>
	</div>

	<!-- the script with all the core of the installation -->
	<script>
		window.onload = () => {
			const pixels = { width: 480, height: 270 };

			// aliases for JS functions
			let sin = Math.sin;
			let cos = Math.cos;
			let int = Math.floor;
			let pi = Math.PI;
			let rand = Math.random;

			// canvas setup for the hydra visuals
			let canvas = document.getElementById('hydra-canvas');
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			canvas.style.width = '100%';
			canvas.style.height = '100%';
			canvas.style.imageRendering = 'pixelated';

			// create a new hydra instance
			var hydra = new Hydra({ 
				canvas: canvas,
				precision: 'mediump',
				detectAudio: false,
			});

			// initialize an instance of p5.js to use functions in this scope
			let p = new p5((p) => {
				p.setup = () => {
					p.noCanvas();
					p.userStartAudio();
				}
			});

			// set resolution for the visuals
			setResolution(pixels.width, pixels.height);

			// initalize solid black screens
			solid().out(o0);
			solid().out(o1);
			render(o3);

			// create a mask (split screen in black/white on half width)
			osc(Math.PI*2,0).thresh(0.5, 0).out(o2);
			
			// start with split screen
			split();

			// storage for incoming parameters from controller
			let c1 = { value: 0, function: 0, switch: 0, sound: null };
			let c2 = { value: 0, function: 0, switch: 0, sound: null };

			// receive messages from the controllers
			let socket = io();
			socket.on('message', (...msg) => {
				// if both controllers' switch is pressed merge the visuals
				if (msg[0].match(/switch/)){
					if (msg[0].match(/control1/)){
						c1.switch = !msg[1];
					} else if (msg[0].match(/control2/)){
						c2.switch = !msg[1];
					}

					if (c1.switch && c2.switch){
						merge();
					} else {
						split();
					}
				}
				// route incoming messages and change values for code
				if (msg[0].match(/control1/)){
					// if the message is comes from controller 1
					if (msg[0].match(/value/)){
						c1.value = msg[1]/1023;
						if (c1.sound){
							c1.sound.value(c1.value);
						}
					}
					else if (msg[0].match(/function/)){
						let f = Math.floor(msg[1]/1024*5);
						// only change something if the function 
						// actually changes (not just the knob position)
						if (f !== c1.function){
							c1.function = f;
							// redraw the visuals with new code
							visual(c1, 'o0');
							// remake the sound with new code
							sound(c1, -1);
						}
					}
				}
				else if (msg[0].match(/control2/)){
					// if the message comes from controller 2
					if (msg[0].match(/value/)){
						c2.value = msg[1]/1023;
						if (c2.sound){
							c2.sound.value(c2.value);
						}
					}
					else if (msg[0].match(/function/)){
						let f = Math.floor(msg[1]/1024*5);
						// only change something if the function 
						// actually changes (not just the knob position)
						if (f !== c2.function){
							c2.function = f;
							// redraw the visuals with new code
							visual(c2, 'o1');
							// remake the sound with new code
							sound(c2, 1);
						}
					}
					else if (msg[0].match(/switch/)){
						c2.switch = !msg[1];
					}
				}
			});

			// Split the visuals into 2 separate screens
			function split(){
				solid().add(src(o0).mask(src(o2)).add(
					src(o1).scale(-1).mask(src(o2).invert(1))
				)).out(o3);

				// display the code in the editor
				displayCode(
					`src(o0).mask(src(o2)).\nadd(src(o1).mask(src(o2).invert(1)))\n.out(o3)`, 'o2');
			}
			
			// Merge the visuals by modulating together with random 
			// modulation option and amount every time started
			function merge(){
				let options = ['modulate', 'modulateKaleid', 'modulateScrollX', 'modulateRotate', 'modulateScale']
				let random = int(rand() * options.length);
				
				let modulation = options[random];
				let modAmount = rand()*4+0.1;
				let mergeCode = `src(o0).\n${modulation}(src(o1), ${modAmount.toFixed(3)})`;

				// display the code in the editor
				displayCode(`${mergeCode}\n.out(o3)`, 'o2');

				// evaluate the code and display the merged visuals
				mergeCode = `solid().add(${mergeCode}).out(o3)`;
				eval(mergeCode);
			}

			// All the different visual code snippets for the installation
			// stored in an object by name and followed by the code
			// ${v} is the variable from the knob
			let codeSnippets = {
				'squiggle' : (o, v) => 
					`gradient(0).pixelate(6,6)
					.hue(() => 1-(${v} * 0.5 + 0.4))
					.mask(shape(8).scale( () => ${v} * 10 + 3, 0.56))
					.rotate(() => ${v} * pi, 1)
					.modulate(noise(1.5, 0.2), () => cos(${v} * pi * 4) * 4 + 5.5)
					.out(${o})`,
				'mosaic' : (o, v) =>
					`osc(4,0.1,() => ${v} * 2 + 1.7).kaleid(3)
					.colorama(() => cos(${v} * pi * 6) * 0.1 + 0.1)  
					.modulatePixelate(voronoi(8, 0.5, 0), () => sin(${v} * pi * 4) * 10 + 11)
					.out(${o})`,
				'smear' : (o, v) =>
					`src(${o})
					.modulate(src(${o}).pixelate(6,6), 0.005)
					.scale(() => sin(${v} * pi * 4) * 0.02 + 1).hue(0.001)
					.diff(osc(2, -0.1, () => ${v} * 2 + 3).mask(shape(2,0.02,0).scrollY(0.5)))
					.out(${o})`,
				'glass' : (o, v) =>
					`osc(2, 0.4, 0)
					.modulateKaleid(shape(() => int(${v} * 4) + 2, 0.2,() => sin(${v} * pi * 9) * 0.5 + 0.5).repeat(3), 6)
					.colorama(() => cos(${v} * pi * 2) * 0.01 + 7)
					.out(${o})`,
				'paint' : (o, v) =>
					`noise(0.4, 0.05)
					.colorama(() => ${v} * 0.01 + 6)
					.hue(() => ${v} * -0.3)
					.modulate(noise(() => cos(${v} * pi * 2) * 2 + 4))
					.out(${o})`,
			}
			
			// Generate the new visual code
			function visual(ctl, out){
				// get the code from the list of options
				let snippets = Object.keys(codeSnippets);
				// apply the parameter value
				let code = codeSnippets[snippets[ctl.function]](out, 'ctl.value');
				// generate the visuals
				eval(code);
				// display the code also as text on the screen
				displayCode(code, out);
			}

			// display the code as text on the screen
			function displayCode(text, element){
				let paragraph = document.getElementById(element);
				paragraph.innerHTML = '';
				let mark = document.createElement('mark');
				mark.innerText = text;
				paragraph.appendChild(mark);
			}

			let soundSnippets = {
				'squiggle' : (o) => { return new Squiggle(o) },
				'mosaic' : (o) => { return new Mosaic(o) },
				'smear' : (o) => { return new Smear(o) },
				'glass' : (o) => { console.log('glass sound') },
				'paint' : (o) => { return new Paint(o) }
			}

			function sound(ctl, out){
				// get the code from the list of options
				let snippets = Object.keys(soundSnippets);

				console.log(ctl.sound);
				if (ctl.sound){
					// delete the previous sound
					ctl.sound.dispose();
					// generate the sound
				}
				ctl.sound = soundSnippets[snippets[ctl.function]](out);
				ctl.sound.value(ctl.value);
			}

			// sound function for the squiggle visual
			// An oscillator bank of 3 oscillators and using 
			// some distortion and delay
			function Squiggle(out){
				this.oscBank = new Array(3);
				this.drive = new p5.Distortion();
				this.reverb = new p5.Reverb();
				
				for (i=0; i<this.oscBank.length; i++){
					this.oscBank[i] = new p5.Oscillator(1, 'sine');
					this.oscBank[i].pan(out);
					this.oscBank[i].start();
					this.oscBank[i].disconnect();
					this.drive.process(this.oscBank[i], 0.001);
				}
				this.reverb.process(this.drive, 5, 5);
				
				this.value = (v) => {
					for (i=0; i<this.oscBank.length; i++){
					let f = p.midiToFreq( (cos(v * 4 * pi) * -0.5 + 0.5) * (i-1) * 0.3 + 38 + (i * 12))
					this.oscBank[i].freq(f, 0.005)
					}
					this.reverb.amp(v * 6 + 0.5, 0.01);
				}
				
				this.dispose = () => {
					let nodes = [...this.oscBank, this.drive, this.reverb];
					for (let i=0; i<nodes.length; i++){
						nodes[i].disconnect();
						nodes[i].dispose();
					}
				}
			}

			// sound function for the mosaic visual
			// An arpeggiating oscillator with delay effect
			// and changing melodic phrase
			function Mosaic(out){
				this.osc = new p5.Oscillator('sine');
				this.osc.pan(out);
				this.osc.disconnect();
				this.osc.start();
				
				this.adsr = new p5.Envelope();
				this.adsr.setADSR(0.001, 0.2, 0, 0);
				
				this.drive = new p5.Distortion();
				this.drive.process(this.osc, 0.005);
				this.drive.disconnect();
				
				this.delay = new p5.Delay();
				this.delay.process(this.drive, 0.316, 0.7, 2500);
				this.delay.drywet(0.4);
				
				this.note = (time) => {
					// let i = this.loop.iterations % this.phrase.length;
					let i = int(Math.random() * this.phrase.length);
					let note = this.phrase[i] + 48;

					this.osc.freq(p.midiToFreq(note), 0, time);
					this.adsr.triggerAttack(this.osc, time);
				}
				
				this.notes = [2,4,5,7,9,11,12,14,16,17,19,21,23,24,26,28,29,31,33,35,36];

				this.phrase = [ 2 ];
				
				this.loop = new p5.SoundLoop(this.note, 0.231);
				this.loop.start();
				
				this.value = (v) => {
					this.phrase = this.notes.slice(0, 3 + v * this.notes.length);
					this.loop.interval = (1 - v) * 0.05 + 0.231;
					this.adsr.setADSR(0.001, (cos(v*pi*4)*0.5+0.5) * 0.4 + 0.05, 0, 0);
				}
				
				this.dispose = () => {
					this.loop.stop();
					let nodes = [this.osc, this.adsr, this.drive, this.delay];
					for (let i=0; i<nodes.length; i++){
						nodes[i].disconnect();
						nodes[i].dispose();
					}
				}
			}

			// sound function for the smear visual
			// Filtered pink noise with a Low Frequency Oscillator
			// and a little Distortion
			function Smear(out){
				this.lfo = new p5.Oscillator('sine');
				this.lfo.start();
				this.lfo.freq(1);
				this.lfo.scale(-1,1,0,1);
				this.lfo.disconnect();
				
				this.noise = new p5.Noise('pink');
				this.noise.pan(out);	
				this.noise.start();
				this.noise.amp(this.lfo);
				this.noise.disconnect();
				
				this.filter = new p5.Filter();
				this.filter.process(this.noise);
				
				this.value = (v) => {
					let f = cos(v * pi * 8) * -0.5 + 0.5;
					this.lfo.freq(f * 12 + 0.5);
					this.filter.freq(p.midiToFreq(f * 60 + 72));
				}
				
				this.dispose = () => {
					let nodes = [this.noise, this.lfo, this.filter];
					for (let i=0; i<nodes.length; i++){
						nodes[i].disconnect();
						nodes[i].dispose();
					}
				}
			}

			function Paint(out){
				this.superSaw = Array(3);
				this.sum = new p5.Gain();
				this.lfo = new p5.Pulse(1, 0.9);
				this.filter = new p5.Filter();
				this.reverb = new p5.Reverb(3, 2);
				// this.drive = new p5.Distortion();
				// this.delay = new p5.Delay();
				
				this.lfo.start();
				this.lfo.disconnect();
				this.lfo.freq(7);
				this.lfo.scale(-1,1,0,1);
				
				for (i=0; i<this.superSaw.length; i++){
					this.superSaw[i] = new p5.Oscillator('sawtooth');
					this.superSaw[i].freq(60);
					this.superSaw[i].pan(out);
					this.superSaw[i].start();
					this.superSaw[i].disconnect();
					this.superSaw[i].amp(this.lfo);
					this.sum.setInput(this.superSaw[i]);
					// this.drive.process(this.oscBank[i], 0.005);
				}
				
				this.sum.disconnect();
				this.filter.process(this.sum);
				this.filter.freq(1500);
				this.filter.disconnect();
				this.reverb.process(this.filter);
				this.reverb.drywet(0.5)
				
				this.value = (v) => {
					for (i=0; i<this.superSaw.length; i++){
						let freq = p.midiToFreq(50 + ((i-1) * (v * 0.4 + 0.01)));
						this.superSaw[i].freq(freq, 1);
					}
					this.filter.freq(p.midiToFreq((1-v) * 30 + 70))
					this.lfo.freq(sin(pi * 2) * 5);
				}

				this.dispose = () => {
					let nodes = [...this.superSaw, this.sum, this.lfo, this.filter, this.reverb];
					for (let i=0; i<nodes.length; i++){
						nodes[i].disconnect();
						nodes[i].dispose();
					}
				}
			}
		}
	</script>
</body>
</html>