<!DOCTYPE html>
<head>
	<title>ABSTRACTION | by Timo Hoogland</title>
	<script src="https://unpkg.com/hydra-synth"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
	<script src="./node_modules/socket.io/client-dist/socket.io.min.js"></script>

	<style>
		@import url('https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap');

		html, body {
			font-family: 'Ubuntu Mono', monospace;
			font-size: 2vw;
			line-height: 1.3;
			width: 100%;
			height: 100%;
			margin: 0px;
			overflow: hidden;
		}

		div {
			display:table; 
			column-count:2; 
			width: 100%;
			height: 50%;
		}

		p {
			/* position: absolute; */
			padding: 5%;
			width: 50%;
			height: 100%;
			border: 0;
			display: table-cell;
			/* white-space: pre; */
		}
		
		mark {
			/* background-color: black; */
			/* color: white; */
			background-color: magenta;
			color: cyan;
			mix-blend-mode: difference;
		}

		.canvas {
			z-index: -1000;
			position: fixed;
		}
	</style>
</head>
<body>
	<canvas id="hydra-canvas" class="canvas"></canvas>
	<div>
		<p id="o0"></p>
		<p id="o1"></p>
	</div>
	<div>
		<p id="o2"></p>
	</div>

	<script>
		const pixels = { width: 160, height: 90 };

		window.onload = () => {
			// canvas setup for the hydra visuals
			let canvas = document.getElementById('hydra-canvas');
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			canvas.style.width = '100%';
			canvas.style.height = '100%';
			canvas.style.imageRendering = 'pixelated';

			// create a new hydra instance
			var hydra = new Hydra({ 
				canvas: canvas,
				precision: 'mediump',
				detectAudio: false
			});

			// set resolution for the visuals
			setResolution(pixels.width, pixels.height);

			// initalize solid black screens
			solid().out(o0);
			solid().out(o1);
			render(o3);

			// create a mask (split screen in black/white on half width)
			osc(Math.PI*2,0).thresh(0.5, 0).out(o2);
			
			// start with split screen
			split();

			// storage for incoming parameters from controller
			let c1 = { value: 0, function: 0 };
			let c2 = { value: 0, function: 0 };
			let isMerged = false;

			// receive messages from the controllers
			let socket = io();
			socket.on('message', (...msg) => {
				// if the controllers are connected via touch merge the visuals
				if (msg[0].match(/switch/)){
					isMerged = !msg[1];
					if (isMerged) merge();
					else split();
				}
				// route incoming messages and change values for code
				else if (msg[0].match(/control1/)){
					// if the message is comes from controller 1
					if (msg[0].match(/value/)){
						c1.value = msg[1]/1023;
					}
					else if (msg[0].match(/function/)){
						c1.function = Math.floor(msg[1]/1024*4);
						// redraw the visuals with new code to output 0
						visual(c1, 'o0');
					}
				}
				else if (msg[0].match(/control2/)){
					// if the message comes from controller 2
					if (msg[0].match(/value/)){
						c2.value = msg[1]/1023;
					}
					else if (msg[0].match(/function/)){
						c2.function = Math.floor(msg[1]/1024*4);
						// redraw the visuals with new code to output 1
						visual(c2, 'o1');
					}
				}
			});

			// Split the visuals into 2 separate screens
			function split(){
				src(o0).mask(src(o2)).add(
					src(o1).mask(src(o2).invert(1))
				).out(o3);

				// display the code in the editor
				displayCode(
					`src(o0).mask(src(o2)).\nadd(src(o1).mask(src(o2).invert(1)))\n.out(o3)`, 'o2');
			}
			
			// Merge the visuals by modulating together
			function merge(){
				src(o0).modulate(src(o1)).out(o3);

				// display the code in the editor
				displayCode(`src(o0)\n.modulate(src(o1))\n.out(o3)`, 'o2');
			}
			
			// a list of all possible visual snippets
			// let codeMap = {
			// 	'noise' : (o, v) => `noise(${v*20})\n.colorama(2)\n.out(${o})`,
			// 	'osc' : (o, v) => `osc(4, 0.2, ${v*10})\n.out(${o})`,
			// 	'shape' : (o, v) => `shape(${v*10})\n.repeat(4, 4)\n.out(${o})`
			// }
			let codeMap = {
				'noise' : (o, v) => `noise(() => ${v}*20)\n.colorama(2).\nout(${o})`,
				'osc' : (o, v) => `osc(4, 0.2, () => ${v}*10)\n.out(${o})`,
				'shape' : (o, v) => `shape(() => ${v}*10).\nrepeat(4, 4).\nout(${o})`
			}
			
			// Generate the new visual code
			function visual(ctl, out){
				// get the code from the list of options
				let snippets = Object.keys(codeMap);
				// apply the parameter value
				let code = codeMap[snippets[ctl.function]](out, 'ctl.value');
				// generate the visuals
				eval(code);
				// display the code also as text on the screen
				displayCode(code, out);
			}

			// display the code as text on the screen
			function displayCode(text, element){
				let paragraph = document.getElementById(element);
				paragraph.innerHTML = '';
				let mark = document.createElement('mark');
				mark.innerText = text;
				paragraph.appendChild(mark);
			}
		}
	</script>
</body>
</html>