<!DOCTYPE html>
<head>
	<title>ABSTRACTION | by Timo Hoogland</title>

	<!-- include the amazing hydra-synth by Olivia Jack -->
	<script src="./node_modules/hydra-synth/dist/hydra-synth.js"></script>
	<!-- socket.io for communication between browser and device -->
	<script src="./node_modules/socket.io/client-dist/socket.io.min.js"></script>

	<style>
		@import url('./fonts/UbuntuMono-Regular.ttf');

		html, body {
			font-family: 'Ubuntu Mono', monospace;
			font-size: 1.7vw;
			line-height: 1.3;
			width: 100%;
			height: 100%;
			margin: 0px;
			overflow: hidden;
		}

		div {
			display:table; 
			column-count:2; 
			width: 100%;
			height: 50%;
		}

		p {
			padding: 5%;
			width: 50%;
			height: 100%;
			border: 0;
			display: table-cell;
		}
		
		mark {
			background-color: magenta;
			color: cyan;
			mix-blend-mode: difference;
		}

		.canvas {
			z-index: -1000;
			position: fixed;
		}
	</style>
</head>
<body>
	<canvas id="hydra-canvas" class="canvas"></canvas>
	<div>
		<p id="o0"></p>
		<p id="o1"></p>
	</div>
	<div>
		<p id="o2"></p>
	</div>

	<script>
		const pixels = { width: 640, height: 360 };

		window.onload = () => {
			// aliases for JS functions
			let sin = Math.sin;
			let cos = Math.cos;
			let int = Math.floor;
			let pi = Math.PI;
			let rand = Math.random;

			// canvas setup for the hydra visuals
			let canvas = document.getElementById('hydra-canvas');
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			canvas.style.width = '100%';
			canvas.style.height = '100%';
			canvas.style.imageRendering = 'pixelated';

			// create a new hydra instance
			var hydra = new Hydra({ 
				canvas: canvas,
				precision: 'mediump',
				detectAudio: false
			});

			// set resolution for the visuals
			setResolution(pixels.width, pixels.height);

			// set tempo and speed
			// bpm = 120;
			// speed = 1;

			// initalize solid black screens
			solid().out(o0);
			solid().out(o1);
			render(o3);

			// create a mask (split screen in black/white on half width)
			osc(Math.PI*2,0).thresh(0.5, 0).out(o2);
			
			// start with split screen
			split();

			// storage for incoming parameters from controller
			let c1 = { value: 0, function: 0, switch: 0 };
			let c2 = { value: 0, function: 0, switch: 0 };

			// receive messages from the controllers
			let socket = io();
			socket.on('message', (...msg) => {
				// if both controllers' switch is pressed merge the visuals
				if (msg[0].match(/switch/)){
					if (msg[0].match(/control1/)){
						c1.switch = !msg[1];
					} else if (msg[0].match(/control2/)){
						c2.switch = !msg[1];
					}

					if (c1.switch && c2.switch){
						merge();
					} else {
						split();
					}
				}

				// route incoming messages and change values for code
				if (msg[0].match(/control1/)){
					// if the message is comes from controller 1
					if (msg[0].match(/value/)){
						c1.value = msg[1]/1023;
					}
					else if (msg[0].match(/function/)){
						c1.function = Math.floor(msg[1]/1024*5);
						// redraw the visuals with new code to output 0
						visual(c1, 'o0');
					}
				}
				else if (msg[0].match(/control2/)){
					// if the message comes from controller 2
					if (msg[0].match(/value/)){
						c2.value = msg[1]/1023;
					}
					else if (msg[0].match(/function/)){
						c2.function = Math.floor(msg[1]/1024*5);
						// redraw the visuals with new code to output 1
						visual(c2, 'o1');
					}
					else if (msg[0].match(/switch/)){
						c2.switch = !msg[1];
					}
				}
			});

			// Split the visuals into 2 separate screens
			function split(){
				solid().add(src(o0).mask(src(o2)).add(
					src(o1).scale(-1).mask(src(o2).invert(1))
				)).out(o3);

				// display the code in the editor
				displayCode(
					`src(o0).mask(src(o2)).\nadd(src(o1).mask(src(o2).invert(1)))\n.out(o3)`, 'o2');
			}
			
			// Merge the visuals by modulating together with random 
			// modulation option and amount every time started
			function merge(){
				let options = ['modulate', 'modulateKaleid', 'modulateScrollX', 'modulateRotate', 'modulateScale']
				let random = int(rand() * options.length);
				
				let modulation = options[random];
				let modAmount = rand()*5+0.1;
				let mergeCode = `src(o0).\n${modulation}(src(o1), ${modAmount.toFixed(3)})`;

				// display the code in the editor
				displayCode(`${mergeCode}\n.out(o3)`, 'o2');

				// evaluate the code and display the merged visuals
				mergeCode = `solid().add(${mergeCode}).out(o3)`;
				eval(mergeCode);
			}

			// All the different visual code snippets for the installation
			let codeMap = {
				'squiggle' : (o, v) => 
					`gradient(0).hue(0.2)
					.colorama(() => sin(${v} * pi * 3) * 0.4 + 0.4)
					.mask(shape(100).scale(() => ${v} * 10 + 2, 0.56))
					.modulate(noise(2, 0.2), () => cos(${v} * pi * 4) * 2 + 4)
					.out(${o})`,
				'mosaic' : (o, v) =>
					`osc(10,0.1,() => ${v} * 1 + 2)
					.colorama(() => cos(${v} * Ï€ * 3) * 0.2 + 0.3)
					.kaleid(4)
					.modulateScrollX(voronoi(16,1,() => sin(${v} * pi * 2)* 0.4))
					.out(${o})`,
				'paint' : (o, v) =>
					`noise(0.6,0.1)
					.colorama(() => ${v} * 0.1 + 4)
					.hue(() => ${v} * -1)
					.modulate(noise(5))
					.out(${o})`,
				'glass' : (o, v) =>
					`osc(3,0.5,5)
					.modulateKaleid(shape(() => int(${v} * 3)+2,0.2,() => sin(${v} * pi * 8) * 0.5 + 0.5).repeat(3), 6)
					.colorama(()=> cos(${v} * pi * 2) * -0.15 + 0.3)
					.out(${o})`,
				'smear' : (o, v) =>
					`src(${o})
					.modulate(noise(1), () => ${v} * 0.01 + 0.003)
					.scale(() => sin(${v} * pi * 4) * 0.01 + 1).hue(1)
					.diff(osc(4, -0.3, () => ${v} + 2 * 2).mask(shape(2, 0.01, 0)), 0.01)
					.out(${o})`
			}
			
			// Generate the new visual code
			function visual(ctl, out){
				// get the code from the list of options
				let snippets = Object.keys(codeMap);
				// apply the parameter value
				let code = codeMap[snippets[ctl.function]](out, 'ctl.value');
				// generate the visuals
				eval(code);
				// display the code also as text on the screen
				displayCode(code, out);
			}

			// display the code as text on the screen
			function displayCode(text, element){
				let paragraph = document.getElementById(element);
				paragraph.innerHTML = '';
				let mark = document.createElement('mark');
				mark.innerText = text;
				paragraph.appendChild(mark);
			}
		}
	</script>
</body>
</html>